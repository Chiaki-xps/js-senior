# 1. Promise

```js
function requestData(url) {
  // 模拟网络请求
  setTimeout(() => {
    // 拿到请求的结果
    // url传入的是coderwhy，请求成功
    if(url === 'coderwhy'){
      // 成功
      let names = ["abc", "cba", "nba"]
      return names
    } else { // 否则请求失败
      // 失败
      let errMessage = "请求失败，url错误"
      return errMessage
    }
    
    
  }， 3000)
}

const result = requestData("coderwhy")

// 上面的代码不难发现，我们的异步请求，即使有返回值也不会传递到我们的result，它只是网络请求或者setTimeout的返回值，并不是requestData的返回值。

// 解决的办法就是传入回调函数，这个回调函数会将结果返回出去，这样子我们就能拿到。
```

```js
/**
 * 这种回调的方式有很多的弊端:
 *  1> 如果是我们自己封装的requestData,那么我们在封装的时候必须要自己设计好callback名称, 并且使用好
 *  2> 如果我们使用的是别人封装的requestData或者一些第三方库, 那么我们必须去看别人的源码或者文档, 才知道它这个函数需要怎么去获取到结果
 */

// request.js
function requestData(url, successCallback, failtureCallback) {
  // 模拟网络请求
  setTimeout(() => {
    // 拿到请求的结果
    // url传入的是coderwhy, 请求成功
    if (url === "coderwhy") {
      // 成功
      let names = ["abc", "cba", "nba"]
      successCallback(names)
    } else { // 否则请求失败
      // 失败
      let errMessage = "请求失败, url错误"
      failtureCallback(errMessage)
    }
  }, 3000);
}

// main.js
requestData("kobe", (res) => {
  console.log(res)
}, (err) => {
  console.log(err)
})

// 更规范/更好的方案 Promise承诺(规范好了所有的代码编写逻辑)
function requestData2() {
  return "承诺"
}

const chengnuo = requestData2()
```

+ 以前的网络异步请求，用的是callback来获取请求数据：
  + 这就需要我们自己来设计回调函数、回调函数的名称、回调函数的使用等；
  + 对于不同的人、不同的框架设计出来的方案是不同的，那么我们必须耐心去看别人的源码或者文档，以便可以理解它这个函数到底怎么用；对于使用callback的成本比较高。
+ Promise是用于解决回调地狱，同时也形成了一个代码规范，就想承诺一样，规范好了所有代码别写逻辑，按照预设的方法去获取就行，而不需要增加增本去阅读一些请求函数的文档查看具体的回调。

## 1. 什么是Promise呢？

+ Promise是一个类，可以翻译成 承诺、许诺 、期约；所以我们可以直接使用类名调用静态方法
+ 当我们需要给予调用者一个承诺：待会儿我会给你回调数据时，就可以创建一个Promise的对象（new Promise）；
  + 意思就是说，我们设计返回的数据的时候，给到调用者一个Promise对象就行了
+ 在通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor
  + 这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject；
  + 当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数；
  + 当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数；

```js
// new的过程会执行类里面的构造方法.
// Promise传入回调函数，这个回调函数会被执行
// 传入的这个函数，被称之为executor
const promise = new Promise((resolve，reject) => {
  console.log("promise传入的函数被执行")
})

// 等价于
class Person {
  constructor(callback) {
    let foo = function() {}
    let bar = function() {}
    // 相当于传入的回调函数，默认会帮助我们把resolve和reject两个函数传入进去
    callback(foo, bar)
  }
}

const p = new Person(() => {
  foo()
  bar()
})
```

```js
function foo() {
  // Promise
  return new Promise((resolve, reject) => {
    resolve("success message")
    // reject("failture message")
  })
}

// main.js

// 这里获得一个promise
const fooPromise = foo()

// then方法会在我们Promise执行resolve函数的时候被回调
// then方法传入的回调函数两个回调函数:
// > 第一个回调函数, 会在Promise执行resolve函数时, 被回调
// > 第二个回调函数, 会在Promise执行reject函数时, 被回调
fooPromise.then((res) => {
  // res会获取到Promise.resolve传入的数据（一般就是网络请求的数据）
  console.log(res)
}, (err) => {
  // res会获取到Promise.reject传入的错误信息
  console.log(err)
})

// // catch方法传入的回调函数, 会在Promise执行reject函数时, 被回调
fooPromise.catch(() => {

})


// 传入的这个函数, 被称之为 executor
// > resolve: 回调函数, 在成功时, 回调resolve函数
// >reject: 回调函数, 在失败时, 回调reject函数
// const promise = new Promise((resolve, reject) => {
//   // console.log("promise传入的函数被执行了")
//   // resolve()
//   reject()
// })

// promise.then(() => {

// })

// promise.catch(() => {

// })


// 钩子函数: hook
function foo(fn) {
  fn()
}

foo(() => {

})


```

现在我们利用Promise重构一下我们一开始利用网络请求回调的代码

```js
// request.js
function requestData(url,) {
  // 异步请求的代码会被放入到executor中
  return new Promise((resolve, reject) => {
    // new的过程中执行请求代码，
    // 模拟网络请求
    setTimeout(() => {
      // 拿到请求的结果
      // url传入的是coderwhy, 请求成功
      if (url === "coderwhy") {
        // 成功
        let names = ["abc", "cba", "nba"]
        // resolve扮演回调函数，然后把网络请求的数据通过某种方式返回出去。
        resolve(names)
      } else { // 否则请求失败
        // 失败
        let errMessage = "请求失败, url错误"
        reject(errMessage)
      }
    }, 3000);
  })
}

// main.js
const promise = requestData("coderwhy")
promise.then((res) => {
  console.log("请求成功:", res)
}, (err) => {
   console.log("请求失败:", err)
})

```

## 2. Promise的代码结构

+ 以将它划分成三个状态：
  + 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝；
    + 当执行executor中的代码时，处于该状态；
  + 已兑现（fulfilled）: 意味着操作成功完成；
    + 执行了resolve时，处于该状态；
  + 已拒绝（rejected）: 意味着操作失败；
    + 执行了reject时，处于该状态；



## 3. Promise重构请求



















































































