# 21. Iterator-Generator

## 1. 什么是迭代器？

+ 迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。
  + 其行为像数据库中的光标，迭代器最早出现在1974年设计的CLU编程语言中；
  + 在各种编程语言的实现中，迭代器的实现方式各不相同，但是基本都有迭代器，比如Java、Python等；

可以理解成迭代器就是一个对象（接口）帮助我们遍历容器对象。迭代器的行为像C语言创建指针，每执行一次，往后移动移动

+ 从迭代器的定义我们可以看出来，迭代器是帮助我们对某个数据结构进行遍历的对象。
+ 在JavaScript中，迭代器也是一个具体的对象，这个对象需要符合迭代器协议（iterator protocol）：
  + 迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式；
  + 那么在js中这个标准就是一个特定的next方法；
    + 迭代器对象里面需要实现一个new函数

+ next方法有如下的要求：
  + 一个无参数或者一个参数（generator特俗的迭代器）的函数，返回一个应当拥有以下两个属性的对象：
  + done（`boolean`）
    + 如果迭代器可以产生序列中的下一个值，则为false。（这等价于没有指定done 这个属性。）
    + 如果迭代器已将序列迭代完毕，则为true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。
  +  value
    + 迭代器返回的任何JavaScript 值。done 为true 时可省略。

```js
// 编写的一个迭代器
const iterator = {
  next: function() {
    return { done: true, value: 123 }
  }
}

// 数组
const names = ["abc", "cba", "nba"]

// 创建一个迭代器对象来访问数组
let index = 0

const namesIterator = {
  // 迭代器必须实现next函数
  next: function() {
    if (index < names.length) {
      // 返回一个对象，里面要有done属性和vlue属性
      return { done: false, value: names[index++] }
    } else {
      // 遍历完会返回一个true，并且数据遍历完最后返回true  
      return { done: true, value: undefined }
    }
  }
}

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next()) // { done: false, value: "nba" }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

// 注意单词
iterator protocol 迭代器协议
iterable protocol 可迭代器对象
两个是不一样的东西
```

```js
// 生成迭代器的函数
function createArrayIterator(arr) {
  let index = 0
  return {
    next: function() {
      if (index < arr.length) {
        return { done: false, value: arr[index++] }
      } else {
        return { done: true, value: undefined } 
      }
    }
  }
}

const names = ["abc", "cba", "nba"]
const nums = [10, 22, 33, 12]

const namesIterator = createArrayIterator(names)
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

const numsIterator = createArrayIterator(nums)
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())

// 创建一个无限的迭代器
function createNumberIterator() {
  let index = 0
  return {
    next: function() {
      return { done: false, value: index++ }
    }
  }
}

const numberInterator = createNumberIterator()
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())

```

## 2. 可迭代对象

+  但是上面的代码整体来说看起来是有点奇怪的：
  + 我们获取一个数组的时候，需要自己创建一个index变量，再创建一个所谓的迭代器对象；
  + 事实上我们可以对上面的代码进行进一步的封装，让其变成一个可迭代对象；
  + 就是将我们的数组，还有index，迭代器功能放入到一个对象里。

![image-20220420201737959](21-迭代器-可迭代对象-生成器用法.assets/image-20220420201737959.png)

+ 什么又是可迭代对象呢？
  + 它和迭代器是不同的概念；

    ```tet
    迭代器是一个对象
    符合迭代器协议（iterator protocal），必须实现next函数
    const iterator = {next: function(){return {done.....}}}
    ```

    ```txt
    可迭代对象也是一个对象
    符合可迭代协议（iterable protocal），必须实现@@iterator方法，利用[Symbol.iterator]函数
    const iterableObj = {[Symbol.iterator]: function(return 迭代器)}
    ```

  + 注意`@@`表示的就是`Symbol.`

  + 当一个对象实现了iterable protocol协议时，它就是一个可迭代对象；
  
  + 这个对象的要求是必须实现@@iterator 方法，在代码中我们使用Symbol.iterator 访问该属性；
+ 当我们要问一个问题，我们转成这样的一个东西有什么好处呢？
  + 当一个对象变成一个可迭代对象的时候，进行某些迭代操作，比如`for...of`操作时，其实就会调用它的`@@iterator` 方法；

```js
// 创建一个可迭代器对象来访问数组
const iterableObj = {
  names: ["abc", "cba", "nba"],
  [Symbol.iterator]: function() {
    let index = 0
    return {
      // 注意细节，这里的next函数不能使用next: function() {}，而是使用箭头函数
      // 因为我们this向上查找的时候，会发现，return返回的是一个对象，意味着我们使用的时候例如
      // 假如定义一个sen得到得到返回的值，然后进行sen.next()的时候会发现，做了隐式绑定，this指向sen，这时候sen里面是找不到names属性的
      // 所以要用箭头函数
      next: () => {
        if (index < this.names.length) {
          return { done: false, value: this.names[index++] }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
}




// iterableObj对象就是一个可迭代对象
// console.log(iterableObj[Symbol.iterator]) // [Function: [Symbol.iterator]]

// 1.第一次调用iterableObj[Symbol.iterator]函数
// 每次调用都会生成的都是新的迭代器
const iterator = iterableObj[Symbol.iterator]()
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())

// // 2.第二次调用iterableObj[Symbol.iterator]函数
const iterator1 = iterableObj[Symbol.iterator]()
console.log(iterator1.next())
console.log(iterator1.next())
console.log(iterator1.next())
console.log(iterator1.next())

// 3.for...of可以遍历的东西必须是一个可迭代对象

// 对象就是不支持for of,因为他不是可迭代的
// const obj = {
//   name: "why",
//   age: 18
// }

// for of其实就是上面的语法糖,最后获取里面value的值
for (const item of iterableObj) {
  console.log(item)
}

```

## 3. 原生迭代器对象

+ 事实上我们平时创建的很多原生对象已经实现了可迭代协议，会生成一个迭代器对象的：
  + String、Array、Map、Set、arguments对象、NodeList集合；

```js
const names = ["abc", "cba", "nba"] // 本质上new Array()
console.log(names[Symbol.iterator]) // [Function: value]

// const iterator1 = names[Symbol.iterator]()
// console.log(iterator1.next())
// console.log(iterator1.next())
// console.log(iterator1.next())
// console.log(iterator1.next())

for (const item of names) {
  console.log(item)
}

// Map/Set
const set = new Set()
set.add(10)
set.add(100)
set.add(1000)

console.log(set[Symbol.iterator])

for (const item of set) {
  console.log(item)
}

// 函数中arguments也是一个可迭代对象
function foo(x, y, z) {
  console.log(arguments[Symbol.iterator])
  for (const arg of arguments) {
    console.log(arg)
  }
}

foo(10, 20, 30)

```

## 4. 可迭代对象的应用

+ 那么这些东西可以被用在哪里呢？
  + JavaScript中语法：for ...of、展开语法（spread syntax）、yield*（后面讲）、解构赋值（Destructuring_assignment）；
  + 创建一些对象时：new Map([Iterable])、new WeakMap([iterable])、new Set([iterable])、new WeakSet([iterable]);
  + 一些方法的调用：Promise.all(iterable)、Promise.race(iterable)、Array.from(iterable);

```js
// 1.for of场景

// 2.展开语法(spread syntax)
const iterableObj = {
  names: ["abc", "cba", "nba"],
  [Symbol.iterator]: function() {
    let index = 0
    return {
      next: () => {
        if (index < this.names.length) {
          return { done: false, value: this.names[index++] }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
}

const names = ["abc", "cba", "nba"]
const newNames = [...names, ...iterableObj]
console.log(newNames)

const obj = { name: "why", age: 18 }
// for (const item of obj) {

// }

// ES9(ES2018)中新增的一个特性: 用的不是迭代器
// newObj不是可迭代对象,但是可以使用展开运算符,因为ES9新增一个针对对象进行了特殊处理而已
const newObj = { ...obj }
console.log(newObj)


// 3.解构语法
const [ name1, name2 ] = names // 迭代器挨个挨个拿到值,然后挨个挨个赋值给到数组里的每一个
// const { name, age } = obj 不一样,也是因为ES9新增的特性

// 4.创建一些其他对象时,根据提示传入可迭代对象
const set1 = new Set(iterableObj)
const set2 = new Set(names)

const arr1 = Array.from(iterableObj)

// 5.Promise.all其实要求传入的就是一个可迭代对象
Promise.all(iterableObj).then(res => {
  console.log(res)
})

```

## 5. 自定义类的迭代

+ 在前面我们看到Array、Set、String、Map等类创建出来的对象都是可迭代对象：
  + 在面向对象开发中，我们可以通过class定义一个自己的类，这个类可以创建很多的对象：
  + 如果我们也希望自己的类创建出来的对象默认是可迭代的，那么在设计类的时候我们就可以添加上`@@iterator`方法；

+ 案例：创建一个classroom的类
  + 教室中有自己的位置、名称、当前教室的学生；
  + 这个教室可以进来新学生（push）；
  + 创建的教室对象是可迭代对象；

```js
// class Person {

// }

// const p1 = new Person()
// const p2 = new Person()
// const p3 = new Person()

// 通过自定义类创建出的对象都可迭代
// 案例: 创建一个教室类, 创建出来的对象都是可迭代对象
class Classroom {
  constructor(address, name, students) {
    this.address = address
    this.name = name
    this.students = students
  }

  entry(newStudent) {
    this.students.push(newStudent)
  }

  [Symbol.iterator]() {
    let index = 0
    return {
      next: () => {
        if (index < this.students.length) {
          return { done: false, value: this.students[index++] }
        } else {
          return { done: true, value: undefined }
        }
      },
      return: () => {
        console.log("迭代器提前终止了~")
        // 要求我们返回这个对象
        return { done: true, value: undefined }
      }
    }
  }
}

const classroom = new Classroom("3幢5楼205", "计算机教室", ["james", "kobe", "curry", "why"])
classroom.entry("lilei")

for (const stu of classroom) {
  console.log(stu)
  // 当我们执行break的时候会在迭代器中执行return
  if (stu === "why") break
}

// 构造函数增加迭代器
function Person() {

}

Person.prototype[Symbol.iterator] = function() {
  
}

```

## 6. 迭代器的中断

+ 迭代器在某些情况下会在没有完全迭代的情况下中断：
  + 比如遍历的过程中通过break、continue、return、throw中断了循环操作；
  + 比如在解构的时候，没有解构所有的值；
+ 那么这个时候我们想要监听中断的话，可以添加return方法：

## 7. 什么是生成器

+ 生成器是ES6中新增的一种函数控制、使用的方案，它可以让我们更加灵活的控制函数什么时候继续执行、暂停执行等。

+ 平时我们会编写很多的函数，这些函数终止的条件通常是返回值或者发生了异常。
+ **生成器函数也是一个函数，但是和普通的函数有一些区别：**
  + 首先，生成器函数需要在function的后面加一个符号：*****
  + 其次，生成器函数可以通过yield关键字来控制函数的执行流程：
  + 最后，生成器函数的返回值是一个Generator（生成器）：
    + 生成器事实上是一种特殊的迭代器；
    + MDN：Instead, they return a special type of iterator, called a Generator.

```js
// 生成器是一种特殊的迭代器，一种函数控制的方案，控制函数暂停和执行
// 普通函数的执行流程
function foo() {
  const value1 = 100
  console.log(value1)

  const value2 = 200
  console.log(value2)

  const value3 = 300
  console.log(value3)
}

foo()

```

```js
// 什么是生成器函数
// function后面带星*，中间多少空格没规定
function* foo() {
  console.log("函数开始执行~")

  const value1 = 100
  console.log("第一段代码:", value1)
  yield

  const value2 = 200
  console.log("第二段代码:", value2)
  yield

  const value3 = 300
  console.log("第三段代码:", value3)
  yield

  console.log("函数执行结束~")
}

// 调用生成器函数时, 会给我们返回一个生成器对象
const generator = foo()

// 开始执行第一段代码
generator.next()

// 开始执行第二端代码
console.log("-------------")
generator.next()
generator.next()
console.log("----------")
generator.next()




```

```js
// 生成器函数
function* foo() {
  console.log("函数开始执行~")

  const value1 = 100
  console.log("第一段代码:", value1)
  yield // 到yield停止

  const value2 = 200
  console.log("第二段代码:", value2)
  yield

  const value3 = 300
  console.log("第三段代码:", value3)
  yield

  console.log("函数执行结束~")
}

// 直接函数执行时其实时不会执行一行代码的
foo()

// 生成器函数返回值是一个Generator（生成器），生成器事实上是一种特俗的迭代器。所以可调next
// 调用生成器函数时, 会给我们返回一个生成器对象
const generator = foo()

// 开始执行第一段代码
generator.next()

// 开始执行第二端代码
console.log("-------------")
generator.next()
generator.next()
console.log("----------")
generator.next()

```

## 8. 生成器函数执行

+ 我们发现上面的生成器函数foo的执行体压根没有执行，它只是返回了一个生成器对象。
  + 那么我们如何可以让它执行函数中的东西呢？调用next即可；
  + 我们之前学习迭代器时，知道迭代器的next是会有返回值的；
  + 但是我们很多时候不希望next返回的是一个undefined，这个时候我们可以通过yield来返回结果；

```js
// 当遇到yield时候值暂停函数的执行
// 当遇到return时候生成器就停止执行
function* foo() {
  console.log("函数开始执行~")

  const value1 = 100
  console.log("第一段代码:", value1)
  // 把return看成特殊的yield，所以遇到return会结束当前代码片段，return的值作为value的返回值，注意我说的value是迭代器的返回值
  // 并且设置done为true，那么后面的next都不会再执行了，结果为{value: 'undefined', done: true}
  yield value1 // 定义返回的value值，如果没有就undefined，可以表达式或者函数等

  const value2 = 200
  console.log("第二段代码:", value2)
  yield value2

  const value3 = 300
  console.log("第三段代码:", value3)
  yield value3

  console.log("函数执行结束~")
  return "123" // 没有写返回值，默认就是undefined，写了返回值，就会认为i时value的返回值
}

// generator本质上是一个特殊的iterator
const generator = foo()
// 生成器本质也是一个迭代器，所以使用next时，代码会执行，并且会返回一个{value:'值'，done:true/false}
console.log("返回值1:", generator.next()) 
console.log("返回值2:", generator.next())
console.log("返回值3:", generator.next())
console.log("返回值3:", generator.next())

// 打印结果
// 函数开始执行~
// 第一段代码: 100
// 返回值1: { value: 100, done: false }
// 第二段代码: 200
// 返回值2: { value: 200, done: false }
// 第三段代码: 300
// 返回值3: { value: 300, done: false }
// 函数执行结束~
// 返回值3: { value: '123', done: true }

```

## 9. 生成器传递参数-next函数

+ 函数既然可以暂停来分段执行，那么函数应该是可以传递参数的，我们是否可以给每个分段来传递参数呢？
  + 答案是可以的；
  + 我们在调用next函数的时候，可以给它传递参数，那么这个参数会作为上一个yield语句的返回值；
  + 注意：也就是说我们是为本次的函数代码块执行提供了一个值；

```js
function* foo(num) {
  console.log("函数开始执行~")

  const value1 = 100 * num
  console.log("第一段代码:", value1)

  // 这个n会是这一段得返回值，同时再遇到下一个next得时候，接受next得参数，作为下一段代码得参数使用
  const n = yield value1

  const value2 = 200 * n
  console.log("第二段代码:", value2)
  const count = yield value2

  const value3 = 300 * count
  console.log("第三段代码:", value3)
  yield value3

  console.log("函数执行结束~")
  return "123"
}

// 生成器上的next方法可以传递参数

// 我们得第一个代码片段想要有参数，可以在一开始调用函数得时候，传入
const generator = foo(5)
// 第一个yield是没有办法传入参数得，因为没有上一个yield得到返回值，所以一开始调用函数得时候传入参数。
console.log(generator.next())
// // 第二段代码, 第二次调用next的时候执行的
// 第二次执行迭代器得时候，这里得参数会赋值给上一次执行得yield得返回值张，并被当前得代码片段所使用
console.log(generator.next(10))
// console.log(generator.next(25))

```

```js
function* foo(num) {
    console.log("函数开始执行~")
  
    const value1 = 100 * num
    console.log("第一段代码:", value1)
  
    // yeild的返回子用于接受下一个next的参数，如果下一个next不传入参数，就会是一个undefined。那个undefined乘以一个数值，就是NaN 
    const n = yield value1
  
    console.log('----', n); // undefined
    const value2 = 200 * n
    console.log("第二段代码:", value2)
    const count = yield value2
  
    const value3 = 300 * count
    console.log("第三段代码:", value3)
    yield value3
  
    console.log("函数执行结束~")
    return "123"
  }
  

  const generator = foo(5)
  console.log(generator.next())
  console.log(generator.next())
```

## 10. 生成器提前结束– return函数

+ 还有一个可以给生成器函数传递参数的方法是通过return函数：
  + return传值后这个生成器函数就会结束，之后调用next不会继续生成值了；

```js
function* foo(num) {
  console.log("函数开始执行~")

  const value1 = 100 * num
  console.log("第一段代码:", value1)
  const n = yield value1

  const value2 = 200 * n
  console.log("第二段代码:", value2)
  const count = yield value2

  const value3 = 300 * count
  console.log("第三段代码:", value3)
  yield value3

  console.log("函数执行结束~")
  return "123"
}

const generator = foo(10)

console.log(generator.next())

// 第二段代码的执行, 使用了return函数，可以传入参数。第二段代码将不执行
// 等价于在第二段代码最前面加了return
// 那么就意味着相当于在第一段代码的后面加上return, 就会提前终端生成器函数代码继续执行
console.log(generator.return(15))
console.log(generator.next())
console.log(generator.next())
console.log(generator.next())
console.log(generator.next())
console.log(generator.next())
console.log(generator.next())


/*
函数开始执行~
第一段代码: 1000
{ value: 1000, done: false }
{ value: 15, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
{ value: undefined, done: true }
*/
```

## 11. 生成器抛出异常– throw函数

+ 除了给生成器函数内部传递参数之外，也可以给生成器函数内部抛出异常：
  + 抛出异常后我们可以在生成器函数中捕获异常；
  + 但是在catch语句中不能继续yield新的值了，但是可以在catch语句外使用yield继续中断函数的执行；

```js
function* foo() {
  console.log("代码开始执行~")

  const value1 = 100
  try {
    yield value1
  } catch (error) {
    console.log("捕获到异常情况:", error)

    yield "abc"
  }

  console.log("第二段代码继续执行")
  const value2 = 200
  yield value2

  console.log("第三段代码继续执行")
  const value3 = 300
  yield value3

  console.log("第四段代码继续执行")
  const value4 = 400
  yield value4

  console.log("代码执行结束~")
}

const generator = foo()

const result = generator.next()
generator.throw("error message")
console.log('---', generator.next());
console.log('+++', generator.next());

// 代码开始执行~
// 捕获到异常情况: error message
// 第二段代码继续执行
// --- { value: 200, done: false }
// 第三段代码继续执行
// +++ { value: 300, done: false }

```

## 12. 生成器替代迭代器

+ 我们发现生成器是一种特殊的迭代器，那么在某些情况下我们可以使用生成器来替代迭代器：

```js
// 创建迭代器
function createArrayIterator(arr) {
     let index = 0
  return {
    next: function() {
      if (index < arr.length) {
        return { done: false, value: arr[index++] }
      } else {
        return { done: true, value: undefined }
      }
    }
  } 
}

const names = ["abc", "cba", "nba"]
const namesIterator = createArrayIterator(names)

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

```

```js
// 改用生成器替换迭代器
function* createArrayIterator(arr) {
    let index = 0
    
    yield arr[index++] // { done: false, value: "abc" }
    yield arr[index++] // { done: false, value: "cba" }
    yield arr[index++] // { done: false, value: "nba" }
    				   // { done: true, value: undefined }
}

const names = ["abc", "cba", "nba"]
const namesIterator = createArrayIterator(names)

```

```js
// 如果只是获取数据
function* createArrayIterator(arr) {
	for (const item of arr) {
    yield item
  }
}

```

+ 事实上我们还可以使用yield*来生产一个可迭代对象：
  + 这个时候相当于是一种yield的语法糖，只不过会依次迭代这个可迭代对象，每次迭代其中的一个值；

```js
// yield* 可迭代对象
function* createArrayIterator(arr) {
    // yield星后面跟上可迭代对象， 后面携带的元素可以一次次被迭代出来
    yield* arr
}

```

```js
// 2. 创建一个函数，这个函数可以迭代一个返回内的数字
// 10 20
function createRangeIterator(start, end) {
    let index = start
    return {
        next: function() {
            if(index < end) {
                return { done: false, value: index++ }
            }else {
                return { done: true, value: undefined }
            }
        }
    }
}

const rangeIterator = createRangeIterator(10, 20)
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())

// 改进
function* createRangeIterator(start, end) {
  let index = start
  while (index < end) {
    yield index++
  }
} 

const rangeIterator = createRangeIterator(10, 20)
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())
console.log(rangeIterator.next())
```

```js
// 3.class案例
class Classroom {
  constructor(address, name, students) {
    this.address = address
    this.name = name
    this.students = students
  }

  entry(newStudent) {
    this.students.push(newStudent)
  }

  // 其他定义函数的办法
  // foo = function() {}
  foo = () => {
    console.log("foo function")
  }

  // [Symbol.iterator] = function*() {
  //   yield* this.students
  // }
  *[Symbol.iterator]() {
    yield* this.students
  }
}

const classroom = new Classroom("3幢", "1102", ["abc", "cba"])
for (const item of classroom) {
  console.log(item)
}

```

## 13. 对生成器的操作

+ 既然生成器是一个迭代器，那么我们可以对其进行如下的操作：

![image-20220425145406258](21-迭代器-可迭代对象-生成器用法.assets/image-20220425145406258.png)

## 14. 异步处理方案

+ 学完了我们前面的Promise、生成器等，我们目前来看一下异步代码的最终处理方案。
+ 需求：
  + 我们需要向服务器发送网络请求获取数据，一共需要发送三次请求；
  + 第二次的请求url依赖于第一次的结果；
  + 第三次的请求url依赖于第二次的结果；
  + 依次类推；

```js
// 需求: 
// 1> url: why -> res: why
// 2> url: res + "aaa" -> res: whyaaa
// 3> url: res + "bbb" => res: whyaaabbb

// request.js
function requestData(url) {
  // 异步请求的代码会被放入到executor中
  return new Promise((resolve, reject) => {
    // 模拟网络请求
    setTimeout(() => {
      // 拿到请求的结果
      resolve(url)
    }, 2000);
  })
}

```

```js
// 1.第一种方案: 多次回调
// 回调地狱
requestData("why").then(res => {
  requestData(res + "aaa").then(res => {
    requestData(res + "bbb").then(res => {
      console.log(res)
    })
  })
})

```

```js
// 2.第二种方案: Promise中then的返回值来解决
requestData("why").then(res => {
  // return new Promise。然后结果友下一个then继续处理
  return requestData(res + "aaa")
}).then(res => {
  return requestData(res + "bbb")
}).then(res => {
  console.log(res)
})

```

```js
// 3.第三种方案: Promise + generator实现
function* getData() {
  const res1 = yield requestData("why")
  const res2 = yield requestData(res1 + "aaa")
  const res3 = yield requestData(res2 + "bbb")
  const res4 = yield requestData(res3 + "ccc")
  console.log(res4)
}

// 1> 手动执行生成器函数
const generator = getData()
// next()放回一个{value:...,done:...},然后拿到里面的value也就是返回的Promise,然后then
generator.next().value.then(res => {
  generator.next(res).value.then(res => {
    generator.next(res).value.then(res => {
      generator.next(res)
    })
  })
})

```

```js
// 3.第三种方案: Promise + generator实现
function* getData() {
  // 注意这个requestData的返回值是一个Promise
  const res1 = yield requestData("why")
  const res2 = yield requestData(res1 + "aaa")
  const res3 = yield requestData(res2 + "bbb")
  const res4 = yield requestData(res3 + "ccc")
  console.log(res4)
}

generator.next().value.then(res => {
  generator.next(res).value.then(res => {
    generator.next(res).value.then(res => {
      generator.next(res)
    })
  })
})

```

```js
// 2> 自己封装了一个自动执行的函数
// 传入一个生成器的函数
function execGenerator(genFn) {
  const generator = genFn()
  function exec(res) {
    const result = generator.next(res)
    if (result.done) {
      return result.value
    }
    result.value.then(res => {
      // 递归
      exec(res)
    })
  }
  exec()
}

execGenerator(getData)
execGenerator(getDepartment)
```

```js
// 3> 第三方包co自动执行
// TJ: co/n(nvm)/commander(coderwhy/vue cli)/express/koa(egg)
// npm inistall co
const co = require('co')
co(getData)

```

```js
// 4.第四种方案: async/await
// 把星变成了async
// yield变成了await
async function getData() {
  const res1 = await requestData("why")
  const res2 = await requestData(res1 + "aaa")
  const res3 = await requestData(res2 + "bbb")
  const res4 = await requestData(res3 + "ccc")
  console.log(res4)
}

getData()

```





```js
关于node打印
function b() {
	
}

console.log(b)

class a {

}

console.log(a);

nodejs里的console.log用的是process.stdout.write()实现的
[Function: b]
[class a]

具体看node文档吧
```











# Symbol的基本使用

+ Symbol是什么呢？Symbol是ES6中新增的一个基本数据类型，翻译为符号。
+ 那么为什么需要Symbol呢？
  + 在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突；
  + 比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下，很容易造成冲突，从而覆盖掉它内部的某个属性；
  + 比如我们前面在讲apply、call、bind实现时，我们有给其中添加一个fn属性，那么如果它内部原来已经有了fn属性了呢？
  + 比如开发中我们使用混入，那么混入中出现了同名的属性，必然有一个会被覆盖掉；
+  Symbol就是为了解决上面的问题，用来生成一个独一无二的值。
  + Symbol值是通过Symbol函数来生成的，生成后可以作为属性名；
  + 也就是在ES6中，对象的属性名可以使用字符串，也可以使用Symbol值；
+ Symbol即使多次创建值，它们也是不同的：Symbol函数执行后每次创建出来的值都是独一无二的；
+ 我们也可以在创建Symbol值的时候传入一个描述description：这个是ES2019（ES10）新增的特性；

```js
// ES6之前，对象得属性名（key）一般是字符串,虽然没有用双引号
// key是不能重复的，重复会被覆盖
var obj = {
    name: 'why',
    friend: {name: 'kobe'}
}

// Symbol是一个函数，但是不是构造函数，不可以用new
// 调用这个函数，生成唯一的值
const s1 = Symbol()
const s2 = Symbol()

console.log(s1 === s2) // false

// ES2019(ES10)中，Symbol可以传入一个描述（descripion），可以是一个String或Number
const s3 = Symbol('aaaa')
// 可以拿到这个描述
console.log(s3.description)

// 注意描述与最终符号的定义和标识无关，只是方便我们调试而已
const a1 = Symbol('aaa')
const a2 = Symbol('aaa')
console..log(a1 ==== a2) //无关


// 3. Symbol值作为key
// 3.1 在定义对象字面量时使用
const obj = {
    [s1]: "abc",
    [s2]: "cba"
}

// 3.2 新增属性
obj[s3] = 'nba'

// 3.3 Object.defineProperty方式,Object.defineProperty(obj, "名", {配置})
const s4 = Sybmol()
Object.defineProperty(obj, s4, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 'mba'
})

// 读取
console.log(obj[s1], obj[s2], obj[s3], obj[s4])
// 注意：不能通过点语法获取
// console.log(obj.s1)

// 4. 使用Symbol作为key的属性名，在遍历或Object.keys等中式获取不到这些Symbol值
// 需要Object.getOWnPropertySymbols来获取所有Symbol的key
console.log(Object.keys(obj)) // [] 获取不到
console.log(Object.getOwnPropertyNames(obj)) // []

// 获取Symbol值得方法
console.log(Object.getOWnPropertySymbols(obj)) // [ Symbol(), Symbol(), Symbol(aaa), Symbol() ]

// 遍历Symbol的key里对应的值
const sKeys = Object.getOWnPropertySymbols(obj)
for(cosnt sKey of sKeys) {
    cosnole.log(obj[sKey])
}
// abc
// cba
// nba
// mba


// 5. Symbol.for(key) 相同的key实现得到的Symbol值一样
const sa = Symbol.for('aaa')
const sb = Symbol.for('aaa')
console.log(sa === sb)  // true
// 获取里面key,Symbol.keyFor
const key = Symbol.keyFor(sa)
console.log(key) //aaa
const sc = Symbol.for(key)
console.log(sa === sc) // true

```





## 1. Symbol作为属性名

+ 我们通常会使用Symbol在对象中表示唯一的属性名：



## 2. 相同值得Symbol

+ 前面我们讲Symbol的目的是为了创建一个独一无二的值，那么如果我们现在就是想创建相同的Symbol应该怎么来做呢？
  + 我们可以使用Symbol.for方法来做到这一点；
  + 并且我们可以通过Symbol.keyFor方法来获取对应的key；



























