# 21. Iterator-Generator

## 1. 什么是迭代器？

+ 迭代器（iterator），是确使用户可在容器对象（container，例如链表或数组）上遍访的对象，使用该接口无需关心对象的内部实现细节。
  + 其行为像数据库中的光标，迭代器最早出现在1974年设计的CLU编程语言中；
  + 在各种编程语言的实现中，迭代器的实现方式各不相同，但是基本都有迭代器，比如Java、Python等；

可以理解成迭代器就是一个对象（接口）帮助我们遍历容器对象。迭代器的行为像C语言创建指针，每执行一次，往后移动移动

+ 从迭代器的定义我们可以看出来，迭代器是帮助我们对某个数据结构进行遍历的对象。
+ 在JavaScript中，迭代器也是一个具体的对象，这个对象需要符合迭代器协议（iterator protocol）：
  + 迭代器协议定义了产生一系列值（无论是有限还是无限个）的标准方式；
  + 那么在js中这个标准就是一个特定的next方法；
    + 迭代器对象里面需要实现一个new函数

+ next方法有如下的要求：
  + 一个无参数或者一个参数（generator特俗的迭代器）的函数，返回一个应当拥有以下两个属性的对象：
  + done（`boolean`）
    + 如果迭代器可以产生序列中的下一个值，则为false。（这等价于没有指定done 这个属性。）
    + 如果迭代器已将序列迭代完毕，则为true。这种情况下，value 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。
  +  value
    + 迭代器返回的任何JavaScript 值。done 为true 时可省略。

```js
// 编写的一个迭代器
const iterator = {
  next: function() {
    return { done: true, value: 123 }
  }
}

// 数组
const names = ["abc", "cba", "nba"]

// 创建一个迭代器对象来访问数组
let index = 0

const namesIterator = {
  // 迭代器必须实现next函数
  next: function() {
    if (index < names.length) {
      // 返回一个对象，里面要有done属性和vlue属性
      return { done: false, value: names[index++] }
    } else {
      // 遍历完会返回一个true，并且数据遍历完最后返回true  
      return { done: true, value: undefined }
    }
  }
}

console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next()) // { done: false, value: "nba" }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next()) // { done: true, value: undefined }
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

// 注意单词
iterator protocol 迭代器协议
iterable protocol 可迭代器对象
两个是不一样的东西
```

```js
// 生成迭代器的函数
function createArrayIterator(arr) {
  let index = 0
  return {
    next: function() {
      if (index < arr.length) {
        return { done: false, value: arr[index++] }
      } else {
        return { done: true, value: undefined } 
      }
    }
  }
}

const names = ["abc", "cba", "nba"]
const nums = [10, 22, 33, 12]

const namesIterator = createArrayIterator(names)
console.log(namesIterator.next())
console.log(namesIterator.next())
console.log(namesIterator.next())

const numsIterator = createArrayIterator(nums)
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())
console.log(numsIterator.next())

// 创建一个无限的迭代器
function createNumberIterator() {
  let index = 0
  return {
    next: function() {
      return { done: false, value: index++ }
    }
  }
}

const numberInterator = createNumberIterator()
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())
console.log(numberInterator.next())

```

## 2. 可迭代对象

+  但是上面的代码整体来说看起来是有点奇怪的：
  + 我们获取一个数组的时候，需要自己创建一个index变量，再创建一个所谓的迭代器对象；
  + 事实上我们可以对上面的代码进行进一步的封装，让其变成一个可迭代对象；
  + 就是将我们的数组，还有index，迭代器功能放入到一个对象里。

![image-20220420201737959](21-迭代器-可迭代对象-生成器用法.assets/image-20220420201737959.png)

+ 什么又是可迭代对象呢？
  + 它和迭代器是不同的概念；

    ```tet
    迭代器是一个对象
    符合迭代器协议（iterator protocal），必须实现next函数
    const iterator = {next: function(){return {done.....}}}
    ```

    ```txt
    可迭代对象也是一个对象
    符合可迭代协议（iterable protocal），必须实现@@iterator方法，利用[Symbol.iterator]函数
    const iterableObj = {[Symbol.iterator]: function(return 迭代器)}
    ```

  + 当一个对象实现了iterable protocol协议时，它就是一个可迭代对象；

  + 这个对象的要求是必须实现@@iterator 方法，在代码中我们使用Symbol.iterator 访问该属性；
+ 当我们要问一个问题，我们转成这样的一个东西有什么好处呢？
  + 当一个对象变成一个可迭代对象的时候，进行某些迭代操作，比如`for...of`操作时，其实就会调用它的`@@iterator` 方法；

```js
关于node打印
function b() {

}

console.log(b)

class a {

}

console.log(a);

nodejs里的console.log用的是process.stdout.write()实现的
[Function: b]
[class a]

具体看node文档吧
```















