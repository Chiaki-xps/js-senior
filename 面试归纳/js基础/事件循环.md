## 1. 什么是进程（Process）？

- 概念：

  - 进程（Process）是计算机中**正在运行的程序实例**，是操作系统进行资源分配和调度的基本单位。简单来说，当你启动一个程序（如浏览器、文本编辑器），操作系统会为它创建一个独立的进程，分配内存、CPU 时间、文件等资源，并管理它的运行状态。
  - **独立性：**每个进程有独立的内存空间、资源和状态，互不干扰（崩溃一个进程不影响其他进程）。
  - **动态性：**进程有生命周期：创建、运行、暂停、终止。
  - **并发性：** 多个进程可以“同时”运行（通过 CPU 时间片轮转，看起来是并行）。
  - **资源分配单位：** 操作系统为每个进程分配 CPU 时间、内存、文件句柄等资源。

- 大白话：
  - 程序运行需要一个专属的内存空间，可以把这内存简单理解成进程
  - 每个应用至少有一个进程、进程之间相互独立、即使要通信，也要双方同意

### 1. 进程的组成

- **代码段**：程序的执行指令（如函数、逻辑）。
- **数据段**：全局变量、静态变量等数据。
- **堆栈**：存放临时变量、函数调用信息。
- **进程控制块（PCB）**：记录进程状态、资源使用、优先级等信息（操作系统管理进程的核心结构）。

### 2. 进程的状态

进程在生命周期中会经历多种状态：

1. **新建（New）**：进程刚被创建。
2. **就绪（Ready）**：已分配资源，等待 CPU 执行。
3. **运行（Running）**：正在使用 CPU 执行指令。
4. **阻塞（Blocked）**：等待外部事件（如用户输入、读取文件）。
5. **终止（Terminated）**：执行完毕或被强制结束。

### 3. 进程间通信（IPC）

**概念：**

- **IPC（Inter-Process Communication，进程间通信）** 是计算机系统中**不同进程之间交换数据或协调任务**的机制。由于操作系统会为每个进程分配独立的资源（如内存空间），进程之间默认无法直接共享数据，因此需要 IPC 技术来实现通信和协作。

**IPC 的核心作用：**

1. **数据传递**：进程间发送消息或共享数据（如文件内容、计算结果）。
2. **任务协调**：同步多个进程的操作（如避免资源竞争）。
3. **扩展能力**：通过多进程协作提升性能（如分布式计算）。
4. 需要注意，数据通信会进行序列化，比如转成 JSON 格式。

**多个进程需要协作时，可通过以下方式通信：**

- **管道（Pipe）**：单向数据流，一端写入，另一端读取。。
- **信号（Signal）**：发送简单通知（如 kill 指令终止进程）。
- **共享内存（Shared Memory）**：多个进程访问同一块内存。
- **消息队列（Message Queue）**：通过队列传递结构化数据。

### 4. js 如何进行进程通信

- 浏览器环境一般是**线程通信**，通过 web workers 创建一个轻量级线程，然后主线程和 Worker 通信
- **数据传递**：通过 `postMessage` 传递数据，数据会被**序列化/反序列化**（类似深拷贝）。
- **无共享内存**：Worker 无法直接访问主线程的 DOM 或全局变量。
- **适用场景**：计算密集型任务（如图像处理、大数据分析）。

```js
// 创建 Worker
const worker = new Worker("worker.js");

// 发送消息到 Worker
worker.postMessage({ type: "start", data: 100 });

// 接收来自 Worker 的消息
worker.onmessage = function (event) {
  console.log("主线程收到消息:", event.data);
};
```

```js
// 接收主线程消息
self.onmessage = function (event) {
  if (event.data.type === "start") {
    const result = heavyCalculation(event.data.data);
    // 发送结果回主线程
    self.postMessage({ status: "done", result });
  }
};

function heavyCalculation(n) {
  // 模拟耗时计算
  return n * 2;
}
```

- Node.js 可以通过 `child_process` 或 `cluster` 模块创建子进程，并通过 **IPC（Inter-Process Communication）** 通信。
- 父子进程通信（使用 `fork`）

```js
// 父
const { fork } = require("child_process");
const child = fork("child.js");

// 发送消息到子进程
child.send({ command: "calculate", value: 50 });

// 接收子进程消息
child.on("message", (msg) => {
  console.log("父进程收到:", msg);
});
```

```js
// 接收父进程消息
process.on("message", (msg) => {
  if (msg.command === "calculate") {
    const result = msg.value * 2;
    // 发送结果回父进程
    process.send({ result });
  }
});
```

## 2. 什么是线程（Thread）？

- **线程（Thread）** 是操作系统能够进行 **CPU 调度和执行的最小单位**，它是进程内的一个独立执行流。一个进程可以包含多个线程，这些线 0 程共享进程的内存和资源，但各自独立执行不同的任务。简单来说，线程是进程的“子任务”，负责在进程中完成具体的操作。

- 进程下至少有一个线程，运行代码的线程被称之为主线程。
- 一般 js 线程中，会创建微任务队列。
- 线程之间是隔离的，所以为了保证代码执行的逻辑性，很难交由其他线程去处理。例如微任务中处理 DOM。其他线程是不能访问主线程的 DOM 的。

* **进程是资源分配的最小单位**：操作系统为进程分配内存、文件等独立资源。
* **线程是 CPU 调度的最小单位**：线程负责执行具体的指令，共享进程的资源。
* **协程（Coroutine）**：比线程更轻量的用户级调度单位（不依赖操作系统调度），但需编程语言或框架支持

## 3. 浏览器有哪些进程和线程？

- **浏览器是一个多进程多线程的应用程序**

- 可以在浏览器的任务管理器中查看当前的所有进程

1. 浏览器进程：主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。

2. 网络进程：负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。

3. **渲染进程：**（一个标签页一般一个渲染进程）渲染进程启动后，会开启一个**渲染主线程**，主线程负责执行 HTML、CSS、JS 代码。
   - 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。（比如百度网页崩溃不会影响其他网页）
   - 渲染进程也负责了 JS 代码的执行。
   - **事件循环就发生在渲染主线程里。**
   - 浏览器**每秒尝试绘制页面约 60 次**
   - 帧 = 1 秒/帧率 60hz 约等于 16.67ms

- [chrome 官方说明文档](https://chromium.googlesource.com/chromium/src/+/main/docs/process_model_and_site_isolation.md#Modes-and-Availability)：未来可能改成一个站点一个进程。不再是一个网页一个进程

## 4. 渲染主线程是如何工作的？（浏览器如何渲染页面）

参考另一个文档

## 5. 如何理解 JS 的异步？

- JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

- 而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。

- 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

- 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，**将事先传递的回调函数包装成任务**，加入到消息队列的末尾排队，等待主线程调度执行。

- 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。
- 使用异步的方式，**渲染主线程永不阻塞**

## 6. JS 会阻碍渲染

```html
<h1>Hello!</h1>
<button>change</button>
<script>
  var h1 = document.querySelector("h1");
  var btn = document.querySelector("button");

  // 死循环指定的时间
  function delay(duration) {
    var start = Date.now();
    while (Date.now() - start < duration) {}
  }

  btn.onclick = function () {
    h1.textContent = "Hi！";
    delay(5000);
  };
</script>
```

- 这段代码执行后，五秒后页面才会发生改变，因为有 delay 进行延迟处理。
- 说明页面的渲染是异步的，尽管里面的内容已经发生了改变，但是 JS 会阻塞渲染主线程。
- JS 会阻碍渲染。

## 7. 任务优先级？

根据 W3C 的最新解释:

- 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。
  在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。
- 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行
  https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint

* 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法
* 在目前 chrome 的实现中，至少包含了下面的队列：

  - 延时队列：用于存放计时器到达后的回调任务，优先级「中」
  - 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」
  - 微队列：用户存放需要最快执行的任务，优先级「最高」

* 添加任务到微队列的主要方式主要是使用 Promise、MutationObserver

### 1. 为什么渲染进程不适用多个线程来处理这些事情？

- 渲染进程（如 Chrome 的 Renderer Process）内部确实采用了多线程架构来提升性能，但关键渲染任务（如样式计算、布局、绘制等）仍主要依赖**主线程（Main Thread）**顺序执行。

#### 渲染进程有哪些线程？

1. **主线程（Main Thread）**
   - 处理核心任务：执行 JavaScript、DOM 解析、样式计算、布局、绘制。
2. **合成线程（Compositor Thread）**
   - 负责将页面分层（Layers），合并最终画面，直接与 GPU 通信。
3. **Raster 线程（Raster Thread）**
   - 将绘制指令转换为位图（光栅化），通常由 GPU 加速。
4. **IO 线程**
   - 处理文件读写、网络请求等异步任务。

尽管有多个线程，**核心渲染阶段（样式 → 布局 → 绘制）仍依赖主线程**，原因如下：

1. DOM 的不可并行性：
   - DOM 是单线程操作的：JavaScript 对 DOM 的修改（如 `element.appendChild()`）必须**顺序执行**，否则会导致状态不一致
   - **根本矛盾**：DOM 的单线程操作模型与多线程性能优化的冲突。
2. 渲染阶段的强依赖关系
   - 渲染流程必须严格按顺序进行：  
     **样式计算 → 布局 → 绘制 → 合成**  
     后一阶段依赖前一阶段的结果，无法并行处理
3. 线程同步的开销
   - 多线程间同步数据（如 DOM 结构、样式结果）需要加锁，可能引发：
     - **死锁风险**：线程互相等待资源释放。
     - **性能损耗**：锁竞争和上下文切换可能抵消并行化的收益。
4. JavaScript 的单线程模型：
   - JavaScript 语言设计为单线程，开发者默认无需考虑多线程同步问题
   - **历史兼容性**：若强行将 DOM 操作多线程化，将导致海量现有网站行为异常

## 8. 事件循环

```txx
事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。
```

```js
// 立即把一个函数添加到微队列
Promise.resolve().then(函数);
```

- 大白话版本：
- 事件循环其实一个过程吧
- 我们的渲染主线程不断进入循环，在这个过程中，每次执行宏任务前会去检查事件队列，如果有微任务就会取出执行，然后继续执行下一个宏任务。这个过程就叫事件队列吧
- 新版本的 W3C 取消了宏任务的说话，
- 题外话：如果把计算量大的处理放到微任务就会导致卡顿，因为微任务优先级高，处理小的计算量更合适。

## 9. JS 中的计时器能做到精确计时吗？为什么？

不行，因为：

1. 计算机硬件没有原子钟，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差

## 10. 什么是消息队列？

- **事件循环（Event Loop）：**事件循环是浏览器（或 JavaScript 运行时）处理异步任务的**整体机制**，它负责协调主线程、消息队列、微任务队列和渲染流程。
  + **核心职责**：
    + 监听任务队列（如宏任务队列、微任务队列）。
    + 按优先级调度任务执行（如先清空微任务，再处理一个宏任务）。
    + 控制渲染时机（如 `requestAnimationFrame` 和页面重绘）。
  + **类比**：事件循环像是一个“调度中心”，不断循环检查并处理任务。

- **消息队列（Message Queue）**：消息队列是事件循环内部的一个**任务存储容器**，主要用于存放**宏任务（Macrotasks）**，如 `setTimeout` 回调、DOM 事件、I/O 完成回调等。
  - **核心特点**：
    - 按先进先出（FIFO）的顺序处理任务。
    - **每次事件循环仅处理一个宏任务**（处理完一个后，会再次检查微任务队列）。
  - **角色**：消息队列是事件循环的“任务仓库”之一，但并非事件循环的全部。
- **事件循环**是 JavaScript 异步任务处理的**整体机制**，包含消息队列、微任务队列、渲染流程等。
- **消息队列**是事件循环中专门存放宏任务的**容器**，是事件循环的一个组成部分。
- **关键区别**：事件循环是动态调度任务的流程，而消息队列是静态存储任务的队列。

## 11. 总结：

- **单线程是异步产生的原因**

- **事件循环是异步的实现方式**

## 12. 一些概念：

### 加锁（Locking）

**加锁**是一种同步机制，用于确保在并发环境中，**同一时间只有一个线程（或进程）能访问某个共享资源**（如内存、文件、数据库记录）。
通过加锁，可以防止多个线程同时修改资源导致的数据不一致问题（即 **竞态条件**，Race Condition）。

### 死锁（Deadlock）

**死锁**是多个线程（或进程）因争夺资源而陷入**无限相互等待**的状态，若无外力干预，所有涉及的线程都无法继续执行。

## 问题：

+ requestAnimationFrame使用
