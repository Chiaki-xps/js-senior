## 0. 一些知识

+ JavaScript的代码执行是在一个单独的线程中执行的:
  + 这就意味着JavaScript的代码,在同一个时刻只能做一件事;
  + 如果这件事是非常耗时的,就意味着当前的线程就会被阻塞;
+ 所以真正耗时的操作,实际上并不是由JavaScript线程在执行的:
  + 浏览器的每个进程是多线程的,那么其他线程可以来完成这个耗时的操作
  + 比如网络请求、定时器,我们只需要在特定的时候,去执行应该有的回调函数即可;
+ **调⽤栈（Call Stack）**
  + JavaScript是单线程的，调⽤栈是⼀个后进先出（LIFO）的数据结构，⽤于存储在程序执⾏过程中创建的所有执⾏上下⽂（Execution Contexts）。每当函数被调⽤时，它的执⾏上下⽂就会被推⼊栈中。函数执⾏完毕后，其上下⽂会从栈中弹出。
+ **任务队列（Task Queue）**
  + 任务队列是⼀种先进先出（FIFO）的数据结构，⽤于存储待处理的事件。这些事件可能包括⽤户交互事件（如点击、滚动等）、⽹络请求完成、定时器到期等。

## 1. 什么是浏览器的事件循环机制

+ **浏览器的事件循环是⼀个在JavaScript引擎和渲染引擎之间协调⼯作的机制。**
  + 主要因为JavaScript是单线程的，所以所有需要被执⾏的操作都需要通过⼀定的机制来协调它们有序的进⾏
  + 它的主要任务是监视调⽤栈（Call Stack）和任务队列（Task Queue）
  + 当调⽤栈为空时，事件循环会从任务队列中取出任务执⾏

+ **事件循环处理异步操作**
  + 执⾏当前宏任务。
  + 执⾏完当前宏任务后，检查并执⾏所有微任务。在微任务执⾏期间产⽣的新的微任务也会被连续执⾏，直到微任务队列清空。
  + 渲染更新界⾯（如果有必要）。
  + 请求下⼀个宏任务，重复上述过程。

+ **宏任务**（MacroTasks）：包括脚本（script的执行）、setTimeout、setInterval、I/O（网络请求回调）、UI 交互事件、UI rendering、setImmediate（NodeJs中） 等。

+ **微任务**（MicroTasks）：包括 Promise.then、Promise.catch、Promise.finally、MutationObserver、process.nextTick（仅在Node.js中）、queueMicrotask等。

**执⾏顺序**：

+ 事件循环在执⾏宏任务队列中的⼀个宏任务后，会查看微任务队列。如果微任务队列中有任务，事件循环会连续执⾏所有微任务直到微任务队列为空。

+ 宏任务的执⾏可能触发更多的微任务，⽽这些微任务会在任何新的宏任务之前执⾏，确保微任务能够在渲染前或下⼀个宏任务之前快速响应。

**⽤途不同**：

+ 由于微任务具有较⾼的执⾏优先级，它们适合⽤于需要尽快执⾏的⼩任务，例如处理异步的状态更新。

+ 宏任务适合⽤于分割较⼤的、需要较⻓时间执⾏的任务，以避免阻塞UI更新或其他⾼优先级的操作。

## 2. 注意的一些细节

+ UI 渲染属于宏任务
+ script脚本的执行是宏任务
+ MutationObserver 是微任务
+ requestIdleCallback 既不是宏任务也不是微任务，`requestIdleCallback` 的回调仅在空闲时触发，没有队列概念。
+ requestAnimationFrame 也不属于宏任务微任务，回调函数会在浏览器**渲染阶段之前**触发
  +  `requestAnimationFrame` 替代 `setTimeout(callback, 16.6)`
+ 在宏任务执行完成后，在下一个宏任务之间可以处理其他实物，比如页面渲染和执行微任务。

## 3. 为什么微任务不适合处理大的任务单元

+ 宏任务一般处理的都是较大的任务单元
  + **任务分片**：可以通过递归或循环将大任务拆分成多个宏任务，每次执行一小部分，让浏览器有机会渲染或处理其他任务。
  + **让步机制**：每个宏任务执行后，浏览器会清空微任务队列并检查是否需要渲染。
+ 微任务不适合处理较大的任务单元
  + **立即性**：微任务队列会在**当前宏任务执行完毕后立即清空**，且必须一次性全部执行完，无法中断。
  + **高优先级**：微任务队列的优先级高于渲染和后续宏任务，会阻塞浏览器渲染和用户交互。
  + **无让步机制**：微任务之间没有让出主线程的机会，必须连续执行。
  + 意味着如果执行在微任务中执行耗时的任务，会出现卡顿。



